[
  
    {
      "title"    : "취약점 진단 스크립트 DevOps 구축",
      "category" : "",
      "tags"     : "Korean and DevOps",
      "url"      : "/2024/02/28/%EC%B7%A8%EC%95%BD%EC%A0%90-%EC%A7%84%EB%8B%A8-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-DevOps-%EA%B5%AC%EC%B6%95/",
      "date"     : "Feb 28, 2024",
      "content": "컨설팅 사업을 위한 인프라 취약점 진단 스크립트 구축에 관한 개요를 제공합니다. 복잡한 유지보수 문제를 해결하기 위해 개별 진단 항목을 독립적으로 개발하고, 이를 하나의 통합 스크립트 파일로 배포하는 방안을 제안합니다. 또한, Docker를 활용한 환경 설정, GitLab과 GitLab Runner를 이용한 CI/CD 파이프라인 구축, 컨테이너 레지스트리 활성화 및 GitLab 백업 설정 방법을 상세히 설명합니다.아직 미완성된 프로젝트이라 추후에 내용이 크게 수정될 가능성이 있습니다.개요컨설팅 사업(인프라 진단)에 필요한 취약점 진단 스크립트의 경우, 고객사의 편의를 위해 하나의 스크립트 파일로 제작되고 있습니다.이러한 이유로 하나의 스크립트 파일로 개발이 진행되면서, 인프라 취약점 진단을 위한 스크립트가 유지보수 측면에서 심각한 어려움을 겪고 있다는 점입니다. 이 스크립트는 대상 마다 차이가 있지만, 적게는 8개에서 많게는 100개에 달하는 진단 항목을 포함하고 있으며, 이로 인해 복잡성이 증가해 유지보수가 매우 어려워졌습니다.이 문제에 대한 해결책으로, 개별 진단 항목을 독립적으로 개발한 후, 이들을 하나의 스크립트 파일로 통합하여 배포하는 방식을 제안합니다. 이 접근법은 개별적인 항목들의 유지보수를 용이하게 하면서도 최종적으로는 고객사에게 간편하게 배포할 수 있는 하나의 통합 스크립트를 제공합니다. 더불어, 많은 진단 대상과 테스트 과정에서의 시간 소모, 그리고 테스트 대상 누락 위험을 고려하여, 자동화된 테스트 방식을 도입하는 것이 필요합니다.따라서, 개별적인 개발과 통합 배포, 그리고 자동화된 테스트를 포함하는 이러한 방안은 개발 효율성을 높이고, 고객사에게 안정적이고 신뢰할 수 있는 서비스를 제공하는 데 크게 기여할 것으로 판단됩니다.프로젝트 파일 구조 초안취약점_진단_프로젝트/│├── linux/                 │   ├── global.sh│   ├── 취약점A/l│   │   ├── test_cases/|	│   │   ├── scenario1.sh|	│   │   ├── scenario2.sh|	│   │   ├── data/|	|	│   └── expected_results/│   │   ├── script.sh│   │   └── .gitlab-ci.yml│   └── 취약점B/│       ├── test_cases/│       ├── script.sh│       └── .gitlab-ci.yml│├── unix/                  │   └── ... (동일한 구조)│├── windows/              │   └── ... (동일한 구조)│├── docs/                  ├── README.md└── .gitignoretest_cases/ 디렉터리의 주요 용도①.테스트 시나리오 저장: 각 취약점에 대해 시뮬레이션할 수 있는 다양한 테스트 시나리오를 저장합니다. 이 시나리오들은 진단 스크립트가 예상대로 작동하는지 검증하는 데 사용됩니다.②.입력 데이터 및 예상 결과: 테스트에 사용될 입력 데이터와 예상되는 결과 값을 저장합니다. 이를 통해 스크립트가 실제 운영 환경과 유사한 조건에서도 정확하게 작동하는지 테스트할 수 있습니다.③.자동화된 테스트 스크립트: 테스트 케이스를 실행하는 자동화된 스크립트나 도구를 포함할 수 있습니다. 이는 CI/CD 파이프라인과 연동되어 자동 테스트를 수행할 수 있습니다.data/ 디렉터리는 테스트 입력에 사용될 데이터 파일 저장expected_results/는 스크립트의 예상 출력 결과를 포함구축1. Docker 구축Ubuntu 서버에 Docker를 설치합니다. Docker는 컨테이너화된 애플리케이션을 실행하는 데 사용됩니다.먼저, 패키지 목록을 최신 상태로 업데이트하고 필요한 패키지들을 설치합니다.sudo apt updatesudo apt install apt-transport-https ca-certificates curl software-properties-commonDocker의 공식 GPG 키를 시스템에 추가합니다. 이는 Docker 패키지의 무결성을 검증하는 데 사용됩니다.curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -Docker의 공식 APT 리포지토리를 시스템의 소스 리스트에 추가합니다.sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;패키지 목록을 다시 업데이트하고 Docker CE(Community Edition)를 설치합니다.sudo apt updatesudo apt install -y docker-ce docker-composeDocker 서비스를 시작하고, docker 명령어를 sudo 없이 사용할 수 있도록 사용자를 docker 그룹에 추가합니다.sudo systemctl start dockersudo systemctl enable dockersudo usermod -aG docker ${USER}사용자를 docker 그룹에 추가한 후에는, 변경 사항을 적용하기 위해 로그아웃하고 다시 로그인해야 할 수도 있습니다.2. Docker Compose 파일 생성version: &#39;3.8&#39;services:  gitlab:    image: gitlab/gitlab-ce:latest    container_name: gitlab    restart: always    ports:      - &#39;8080:80&#39;      - &#39;8081:443&#39;      - &#39;8082:22&#39;    volumes:      - $HOME/gitlab/config:/etc/gitlab      - $HOME/gitlab/logs:/var/log/gitlab      - $HOME/gitlab/data:/var/opt/gitlab    networks:      - gitlab-network  registry:    image: registry:2    container_name: gitlab-registry    ports:      - &#39;5000:5000&#39;    volumes:      - $HOME/gitlab/registry:/var/lib/registry    networks:      - gitlab-networknetworks:  gitlab-network:    driver: bridge      version: Docker Compose 파일의 버전을 명시합니다. 3.8은 현재 널리 사용되는 버전입니다.    services: 실행하려는 각 서비스(컨테이너)를 정의합니다.          gitlab: GitLab 컨테이너의 구성입니다.                  image: 사용할 이미지. 여기서는 GitLab의 최신 커뮤니티 에디션을 사용합니다.          ports: 호스트와 컨테이너 간 포트 매핑. GitLab 웹 인터페이스와 SSH 접근을 위해 필요합니다.          volumes: 데이터, 로그, 설정 파일을 위한 볼륨 마운트.                    registry: Docker Registry 컨테이너의 구성입니다.                  image: Docker Registry 이미지.          ports: Docker Registry에 접근하기 위한 포트 매핑.          volumes: Docker Registry의 데이터 저장을 위한 볼륨 마운트.                      networks: 사용할 네트워크를 정의합니다. 여기서는 간단한 브리지 네트워크를 사용합니다.👉 services의 registry은 컨테이너 레지스트리를 구성하기 위한 컨테이너이다.👉 만약 컨테이너 레지스트리를 사용 안 할 예정이라면, 선언을 안해도 상관 없음.3. GitLab 서비스 구성설정을 적용하고 GitLab 서비스를 시작하기 위해 터미널에서 다음 명령을 실행합니다.docker-compose up -dGitLab 서비스를 중지하고 컨테이너를 제거하려면 다음 명령을 사용합니다.docker-compose down이러한 설정을 통해 GitLab을 쉽게 배포하고 관리할 수 있습니다.필요에 따라 GitLab의 설정을 조정하거나 추가 기능을 활성화하기 위해 gitlab.rb 파일을 편집할 수도 있습니다.4. root 계정 비밀번호초기 비밀번호를 다음 명령을 사용하여 출력할 수 있습니다. 주의할 점은 해당 방법은 초기 세팅부터 24시간동안만 유지됩니다.docker exec -it &amp;lt;Gitlab 컨테이너 이름&amp;gt; /bin/bash cat /etc/gitlab/initial_root_password | grep Password:Docker를 사용하는 경우, GitLab 컨테이너에 접속합니다.docker exec -it gitlab bashGitLab 컨테이너 내부에서 GitLab 콘솔을 실행합니다.gitlab-rails consoleGitLab 콘솔에서 다음 명령어를 실행하여 관리자 비밀번호를 재설정합니다. 여기서 your-new-password는 원하는 새 비밀번호로 대체합니다.user = User.where(id: 1).firstuser.password = &#39;your-new-password&#39;user.password_confirmation = &#39;your-new-password&#39;user.save!exit변경 사항을 적용하기 위해 GitLab 서비스를 재설정 및 재시작할 수 있습니다.gitlab-ctl reconfiguregitlab-ctl restart내부 설정1. Custom Git clone URL for HTTP(S)회사 내에서 사용할 것이기 때문에, 내부망의 IP 주소로 사용할 것이다. 하지만 Gitlab의 경우, 기본값으로 초기 설정된 도메인 주소로 설정되어있다. 이러한 설정을 바꾸지 않으면, 추후 CI의 자동화 서버에서 git clone을 하게되는데 도메인 주소로 clone하게 된다. 자동화 서버 내 Hosts에 Gitlab 서버 IP 주소와 도메인이 매핑되어있지 않기 때문에, 에러가 발생된다.문제점을 해결하기 위해, 도메인을 사용하지 않고 IP 주소를 사용한다는 설정을 해줘야 한다.관리자 로그인 &amp;gt; Configure Gitlab &amp;gt; Settigs &amp;gt; General &amp;gt; Visibility and access controls &amp;gt; Custom Git clone URL for HTTP(S) 에서 http://&amp;lt;Gitlab 서버의 IP주소&amp;gt;:&amp;lt;Gitlab 포트&amp;gt;/으로 설정하면 된다.주의할 점은 root 경로를 기입해줘야 404 상태코드가 발생이 안된다는 것이다.ex) http://192.168.0.35:8080 - X, http://192.168.0.35:8080/ - O2. 컨테이너 레지스트리 활성화나의 목표는 진단 스크립트 환경을 컨테이너로 돌릴 수 있다면, 돌리고 할 수 없다면 서버 구축 후 SSH으로 CI를 구축하는 것이다. 이를 위해 커스텀 컨테이너 이미지를 직접 생성해야하고, 생성한 이미지를 저장소에 저장을 해야한다.기본 리눅스 컨테이너에 net-tools, service, systemctl 등이 설치가 되어있지 않고, apt 명령어를 통해 설치가 불가능하여 커스텀 이미지를 생성해야 함.회사 사규에 회사 자산이 외부로 노출되는 것을 방지하고 있기 때문에 서버 내 컨테이너 저장소를 구축하여 저장하려고 한다. 이를 위해 Gitlab의 컨테이너 레지스트리를 구축해야 한다.GitLab 서비스의 설정 파일(gitlab.rb)에서 Container Registry를 활성화하고 구성합니다.다음 설정을 gitlab.rb에 추가하거나 수정합니다.gitlab_rails[&#39;registry_enabled&#39;] = truegitlab_rails[&#39;registry_host&#39;] = &quot;&amp;lt;호스트 IP 주소&amp;gt;&quot;gitlab_rails[&#39;registry_port&#39;] = &quot;5000&quot;gitlab_rails[&#39;registry_api_url&#39;] = &quot;http://&amp;lt;호스트 IP 주소&amp;gt;:5000&quot;Docker compose 파일에 $HOME/gitlab/config:/etc/gitlab하였기 때문에 컨테이터 내부에서 말고 호스트 내부의 $HOME/gitlab/config/gitlab.rb 파일을 수정해도 상관없음.변경사항을 적용하기 위해 GitLab을 재구성하고 재시작합니다.gitlab-ctl reconfiguregitlab-ctl restart설정이 잘 되었다면, 프로젝트를 생성한 후 사이드 메뉴에서 Project &amp;gt; Deploy &amp;gt; Container Registry가 존재하는지 확인을 해야한다.만약 메뉴가 존재하지 않는다면, 설정이 먹히지 않았다는 것이다. 이럴 땐, registry 컨테이너가 동작하고 있는지와 에러 로그를 확인하여 문제점을 해결하면 된다.이미지를 푸시하고 풀하는 방법은 다음과 같습니다.# 로그인docker login &amp;lt;호스트 IP 주소&amp;gt;:5000# 이미지 푸시docker push &amp;lt;호스트 IP 주소&amp;gt;:5000/your-username/your-project/your-image:tag# 이미지 풀docker pull &amp;lt;호스트 IP 주소&amp;gt;:5000/your-username/your-project/your-image:tagdocker 로그인은 Gitlab 계정 정보를 입력하면 된다.Push가 무사히 완료가 되면, 위 사진처럼 컨테이너 이미지가 저장이 되었다는 것을 확인할 수 있다.3. Gitlab runner 구축이제 CI/CD를 구축하려면, Gitlab runner을 구축하여 저장소 내부의 .gitlab-ci.yml 파일을 통해 CI/CD를 이용할 수 있다.아래는 GitLab Runner를 추가한 docker-compose.yml 파일의 예시입니다version: &#39;3.8&#39;services:  gitlab:    image: gitlab/gitlab-ce:latest    container_name: gitlab    restart: always    ports:      - &#39;8080:80&#39;      - &#39;8081:443&#39;      - &#39;8082:22&#39;    volumes:      - $HOME/gitlab/config:/etc/gitlab      - $HOME/gitlab/logs:/var/log/gitlab      - $HOME/gitlab/data:/var/opt/gitlab    networks:      - gitlab-network  registry:    image: registry:2    container_name: gitlab-registry    ports:      - &#39;5000:5000&#39;    volumes:      - $HOME/gitlab/registry:/var/lib/registry    networks:      - gitlab-network  gitlab-runner:    image: gitlab/gitlab-runner:latest    container_name: gitlab-runner    restart: always    volumes:      - $HOME/gitlab-runner/config:/etc/gitlab-runner      - /var/run/docker.sock:/var/run/docker.sock    networks:      - gitlab-networknetworks:  gitlab-network:    driver: bridge  image: GitLab Runner 서비스에 사용될 Docker 이미지를 지정합니다. 여기서는 GitLab에서 제공하는 최신 버전의 gitlab/gitlab-runner 이미지를 사용합니다.  container_name: 컨테이너의 이름을 gitlab-runner로 설정합니다. 이 이름은 Docker 환경 내에서 해당 컨테이너를 식별하는 데 사용됩니다.  restart: 컨테이너의 재시작 정책을 always로 설정합니다. 이는 Docker 호스트가 재부팅되거나 컨테이너가 다른 이유로 중지될 경우 자동으로 재시작되도록 합니다.  volumes:          $HOME/gitlab-runner/config:/etc/gitlab-runner: GitLab Runner의 설정 파일들을 저장하기 위한 볼륨을 마운트합니다. 이 경로에는 Runner의 구성 파일과 등록 정보가 저장됩니다.      /var/run/docker.sock:/var/run/docker.sock: 호스트 시스템의 Docker 소켓을 컨테이너 내부로 마운트합니다. 이를 통해 GitLab Runner 컨테이너가 호스트의 Docker 엔진을 사용하여 다른 Docker 컨테이너를 생성하고 관리할 수 있습니다. 이 방법은 Docker-in-Docker(DinD)를 사용하는 것과는 다른 접근 방식입니다.        networks: GitLab Runner가 gitlab-network라는 Docker 네트워크를 사용하도록 설정합니다. 이 네트워크는 GitLab 서비스와 통신하는 데 사용됩니다.변경 사항을 적용하기 위해 현재 실행 중인 서비스를 중지합니다.    docker-compose down        변경된 docker-compose.yml 파일을 사용하여 모든 서비스를 다시 시작합니다.    docker-compose up -d        Gitlab에 관리자로 로그인 후 Admin Area &amp;gt; CI/CD &amp;gt; Runners에서 Runner 토큰 확인Gitlab Runner 컨테이너에 접근하여, Runner를 등록합니다.    docker exec -it gitlab-runner bashgitlab-runner register        등록 시 물어보는 항목은 아래와 같음    GitLab 인스턴스 URL (http://&amp;lt;gitlab-host&amp;gt;:&amp;lt;gitlab-port&amp;gt;).  위에서 얻은 Registration Token.  Runner 설명 (예: my-runner).  Runner 태그 (선택사항).  Executor 선택 (Docker를 추천합니다).Executor 선택은 현재 도커 컨테이너로 구축하는 중이라서 Docker로 선택하였습니다.만약 VM이라던가, 다른 서버로 연결하여 한다면 SSH로 선택하여 Runner를 추가하면 됩니다.등록에 성공하면, Runners에 등록된 인스턴스가 보이게 됩니다.4. Gitlab 백업 설정GitLab 컨테이너에서 백업 명령을 실행해야 합니다.docker exec -it gitlab bash$ gitlab-backup createGitLab의 모든 중요 데이터(데이터베이스, 업로드된 파일, 리포지토리 등)를 백업합니다. 백업 파일은 /var/opt/gitlab/backups 디렉토리에 저장됩니다.백업한 데이터를 복구하려면, 백업 파일을 원래의 위치로 복원하고 GitLab을 재시작해야 합니다. GitLab 데이터 복구 명령은 다음과 같습니다.$ gitlab-backup restore BACKUP=backup_file_name위와 같이 하면 Gitlab 데이터를 백업할 수 있다. 하지만, 주기적으로 백업을 못한다는 점과 gitlab 설정파일은 별도로 저장을 해줘야 한다는 점이 단점이다.이를 위해서 shell script 파일을 만들어서 Crontab으로 주기적인 백업과 gitlab 설정파일을 백업하도록 하겠다.#!/bin/bashBACKUP_DIR=&quot;$HOME/gitlab/backup&quot;  # Gitlab 데이터 백업docker exec -t gitlab gitlab-backup create  # 백업 파일 이름 가져오기BACKUP_FILE=$(docker exec -t gitlab ls -t /var/opt/gitlab/backups | head -n 1 | tr -d &#39;\r&#39;)  # 백업 파일을 호스트 시스템으로 복사docker cp &quot;gitlab:/var/opt/gitlab/backups/$BACKUP_FILE&quot; &quot;$BACKUP_DIR/gitlab_data/&quot;  # Gitlab 설정 파일 백업GITLAB_CONFIG=&quot;$HOME/gitlab/config/gitlab.rb&quot;  # 현재 날짜와 시간을 YYYYMMDD_HHMM 형식으로 가져오기CURRENT_DATE=$(date +&quot;%Y%m%d_%H%M&quot;)cp &quot;$GITLAB_CONFIG&quot; &quot;$BACKUP_DIR/gitlab_conf/gitlab_$CURRENT_DATE.rb&quot;계속 저장만 하면 용량이 부족할 수 있기 때문에, 90일이 지난 백업 파일은 삭제하도록 하기 위해 Shell Script를 만들었다.#!/bin/bash# 백업 파일이 저장된 디렉토리BACKUP_DIR=&quot;$HOME/gitlab/backup&quot;# 90일보다 오래된 백업 파일 삭제find &quot;$BACKUP_DIR/gitlab_conf/&quot; -type f -name &quot;*.rb&quot; -mtime +90 -exec rm {} \;find &quot;$BACKUP_DIR/gitlab_data/&quot; -type f -name &quot;*.tar&quot; -mtime +90 -exec rm {} \;이제 해당 스크립트를 일정 주기로 돌릴 Crontab에 설정을 해야한다.귀찮은 작업이라고 판단되어, 자동 등록 스크립트를 만들었다.#!/bin/bash# 백업 및 삭제 스크립트 경로BACKUP_DIR=&quot;$HOME/gitlab/backup&quot;GITLAB_BACKUP_SCRIPT=&quot;$BACKUP_DIR/gitlab_backup.sh&quot;BACKUP_DEL_SCRIPT=&quot;$BACKUP_DIR/backup_del.sh&quot;  # crontab에 추가할 내용을 임시 파일에 작성CRON_FILE=&quot;/tmp/crontab-$$&quot;crontab -l &amp;gt; $CRON_FILE 2&amp;gt;/dev/null || trueecho &quot;0 0 * * * $GITLAB_BACKUP_SCRIPT&quot; &amp;gt;&amp;gt; $CRON_FILEecho &quot;0 12 * * * $GITLAB_BACKUP_SCRIPT&quot; &amp;gt;&amp;gt; $CRON_FILEecho &quot;0 1 * * * $BACKUP_DEL_SCRIPT&quot; &amp;gt;&amp;gt; $CRON_FILEecho &quot;0 13 * * * $BACKUP_DEL_SCRIPT&quot; &amp;gt;&amp;gt; $CRON_FILE  # crontab 업데이트crontab $CRON_FILE  # 임시 파일 삭제rm -f $CRON_FILE실행 권한을 부여해서 동작시키면 등록이 완료된다.",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2024/02/28/%EC%B7%A8%EC%95%BD%EC%A0%90-%EC%A7%84%EB%8B%A8-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-DevOps-%EA%B5%AC%EC%B6%95/'> <img src='/images/Post-02.jpg' alt='취약점 진단 스크립트 DevOps 구축'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>13 min read <time class='article__date' datetime='2024-02-28T19:50:00+09:00'>Feb 28, 2024</time> </span> </div><h2 class='article__title'>취약점 진단 스크립트 DevOps 구축</h2> <p class='article__excerpt'>컨설팅 사업을 위한 인프라 취약점 진단 스크립트 구축에 관한 개요를 제공합니다. 복잡한 유지보수 문제를 해결하기 위해 개별 진단 항목을 독립적으로 개발하고, 이를 하나의 통합 스크립트 파일로 배포하는 방안을 제안합니다. 또한, Docker를 활용...</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='LRTK'><img class='article__author-image' src='/images/author.jpeg' alt='LRTK's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>LRTK</a><span> in </span> <span class='article-tags'> <a href='/tag/Korean' class='article__tag'>Korean</a>  <a href='/tag/DevOps' class='article__tag'>DevOps</a> </span></div></div></div></div></div>"
    } ,
  
    {
      "title"    : "Summary of JWT Vulnerabilities",
      "category" : "",
      "tags"     : "English, Web, and JWT",
      "url"      : "/2024/01/26/Summary-of-JWT-Vulnerabilities/",
      "date"     : "Jan 26, 2024",
      "content": "I’ve briefly summarized the main vulnerabilities of JWT (JSON Web Token), focusing on the security aspects of JWT. This includes unverified signatures, information leakage, algorithm manipulation, vulnerabilities related to JWK and JKU, and vulnerabilities in the kid field.JWT ConceptWhat is JWT?JWT stands for JSON Web Token. It is a compact and self-contained way to securely transmit small amounts of data as a JSON object, defined by the web standard (RFC 7519).✓ Compact: This means that JWT stores information in a relatively small size, making it easy to transmit over networks and include in HTTP headers.✓ Self-contained: This indicates that JWT contains all the necessary information within itself.For secure transmission of token information, it is digitally signed. The signature commonly uses various algorithms like HMAC, RSA, etc.JWT StructureJWT consists of three parts:  Header: Contains information about the type of token (JWT) and the signature algorithm used (HMAC, RSA, etc.).  Payload: Contains Claim information to be included in the token. Claims can include attributes about the token user or additional data.  Signature: Combines the header and payload and signs them using the provided algorithm. This signature ensures the integrity and authentication of the token.Each part is separated in the form of aaaa.bbbb.cccc, and the values of the Header and Payload are base64 encoded.Since base64 can be decoded at any time, digital signing with the Signature is done to maintain the integrity of the Header and Payload.In other words, even if the Header and Payload are tampered with, the Signature verification can detect this tampering.JWT UsageJWT is mainly used for user authentication and information exchange. When a user logs in, the server returns the user’s information in a JWT. Then, the user can authenticate themselves in subsequent server requests using this JWT.Advantages  Self-contained: JWT contains all necessary information, eliminating the need for a separate state store, which is advantageous for implementing stateless servers.  Security: The inclusion of a digital signature guarantees data integrity.  Scalability: Easily used across various systems and languages.Disadvantages  Limitations of Stateless: Since JWT is stateless, once issued, tokens are difficult to manage centrally on the server. This can lead to challenges in handling token expiration or cancellation.  Token Expiration Handling: JWT can set expiration times, but once issued, the token remains valid until that time, making it difficult to expire early.  Token Size: JWT can grow in size as it contains all necessary information, impacting network bandwidth and potentially causing performance degradation, especially in mobile environments.  Performance Degradation: Each time a server verifies a token, it must compute the signature, which can cause performance issues in high-load environments.Vulnerabilities Summary      Unverified SignatureFailing to properly verify the Signature can lead to vulnerabilities like elevation of privileges and account takeover by merely tampering with the Payload.        Information LeakageThis occurs when the Payload, which is only Base64 encoded and not encrypted, can be decoded and read by anyone, leading to the risk of sensitive data exposure.    Algorithm Manipulation                  None AlgorithmA vulnerability exists when the alg field is set to none, considering the token valid without any signature verification. This allows attackers to tamper with the token’s payload without a signature, and the system might mistakenly recognize it as valid.                    Changing Asymmetric Encryption Algorithm to SymmetricA vulnerability exists when changing an asymmetric encryption algorithm to a symmetric one and using the public key as a symmetric key (secret key or pre-shared key). This allows attackers to tamper with the payload and still pass signature verification.                  JWK InjectionThis occurs when including a JWK in the JWT header and directly providing public key information. Attackers can insert their own JWK into the tampered token’s header and create a signature with the corresponding secret key. If the server uses this JWK without verification to validate the token’s signature, the tampered token may be mistakenly recognized as valid.        JKU SpoofingThis happens when the server uses a JSON Web Key (JWK) obtained from the JKU URL in the header without verification to validate the JWT’s signature. Attackers can manipulate the JKU claim to insert their own JWK URL, creating a tampered token signed with their key. If the server does not verify the authenticity of the altered JKU URL and uses it, the tampered token may be recognized as valid, exposing the server to security risks.    Vulnerability in the ‘kid’ FieldThis occurs during the process of the server using the kid value in the token’s header to find the key for token validation. The server searches the DB or file system for the key corresponding to the kid value. However, if the kid value is used without verification, attackers can manipulate this value to attempt attacks like SQL Injection, Path Traversal, or OS Command Injection. Such attacks can threaten server security and bypass token verification or cause other damage to the system. Therefore, the server needs a process to sufficiently verify and filter the kid value before use, ensuring it comes from a trusted source.",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2024/01/26/Summary-of-JWT-Vulnerabilities/'> <img src='/images/Post-01.jpg' alt='Summary of JWT Vulnerabilities'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>5 min read <time class='article__date' datetime='2024-01-26T21:51:00+09:00'>Jan 26, 2024</time> </span> </div><h2 class='article__title'>Summary of JWT Vulnerabilities</h2> <p class='article__excerpt'>I&#39;ve briefly summarized the main vulnerabilities of JWT (JSON Web Token), focusing on the security aspects of JWT. This includes unverified signatures, information leakage, algorithm manipulation, vulnerabilities related to JWK and JKU, and vulnerabilities in the `kid` field.</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='LRTK'><img class='article__author-image' src='/images/author.jpeg' alt='LRTK's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>LRTK</a><span> in </span> <span class='article-tags'> <a href='/tag/English' class='article__tag'>English</a>  <a href='/tag/Web' class='article__tag'>Web</a>  <a href='/tag/JWT' class='article__tag'>JWT</a> </span></div></div></div></div></div>"
    } ,
  
    {
      "title"    : "JWT 취약점 정리",
      "category" : "",
      "tags"     : "Korean, Web, and JWT",
      "url"      : "/2024/01/26/JWT-%E1%84%8E%E1%85%B1%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%8C%E1%85%A5%E1%86%B7-%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5/",
      "date"     : "Jan 26, 2024",
      "content": "JWT (JSON Web Token)의 주요 취약점들에 대해 간략하게 정리하였습니다. 서명 미검증, 정보 누출, 알고리즘 변경, JWK 및 JKU 관련 취약점, 그리고 kid 필드 취약점 등 JWT의 보안 측면에 중점을 두고 설명하고 있습니다.JWT 개념JWT 이란?JWT은 JSON Web Token의 약자로, 웹 표준(RFC 7519)에 따라 정의된, 소량의 데이터를 JSON 객체로 안전하게 전송하기 위한 compact하고 self-contained 방식입니다.✓ compact : JWT가 비교적 작은 크기로 정보를 저장하며, 이로 인해 네트워크를 통한 전송이나 HTTP 헤더에 포함시키기 용이하다는 것을 의미✓ self-contained : JWT가 모든 필요한 정보를 스스로 내장하고 있다는 의미토큰 정보를 안전하게 전송하기 위해 디지털 서명이 되어 있습니다. 서명은 보통 HMAC, RSA 등의 여러 알고리즘을 사용하고 있습니다.JWT 구조JWT는 세 부분으로 구성됩니다.  Header : 토큰의 유형(JWT)과 사용된 서명 알고리즘(HMAC, RSA 등)에 대한 정보를 포함합니다.  Payload : 토큰에 담길 Claim 정보가 들어있습니다. Claim은 토큰 사용자에 대한 속성이나 추가 데이터를 포함할 수 있습니다.  Signature : 해더와 페이로드를 합쳐서, 제공된 알고리즘을 사용하여 서명합니다. 이 서명은 토큰의 무결성과 인증을 보장합니다.각 부분들은 aaaa.bbbb.cccc의 형태로 구분되어 있으며, Header와 Payload의 값은 base64로 인코딩되어 있습니다.base64은 언제든지 디코딩할 수 있기에 Header와 Payload의 무결성을 지키기 위하여 Signature으로 디지털 서명을 하게 됩니다.즉, Header와 Payload을 변조를 하더라고 Signature의 검증을 통해 변조 탐지가 된다는 것입니다.JWT의 사용JWT는 주로 사용자 인증과 정보 교환에 사용됩니다. 사용자가 로그인하면 서버는 사용자의 정보를 JWT에 담아 반환합니다. 이후 사용자는 해당 JWT를 통해 서버에 요청을 할 때마다 자신을 인증할 수 있습니다.장점  자가 포함: JWT는 필요한 모든 정보를 자체적으로 포함하기 때문에, 별도의 상태 저장소가 필요 없어 상태 비저장(stateless) 서버 구현에 유리합니다.  보안: 디지털 서명이 포함되어 있어 데이터 무결성을 보장합니다.  확장성: 다양한 시스템과 언어에서 쉽게 사용될 수 있습니다.단점  상태 비저장(stateless)의 한계: JWT는 상태 비저장 방식이므로, 일단 발급된 토큰은 서버에서 중앙집중식으로 관리하기 어렵습니다. 이는 토큰의 만료나 취소를 처리하는 데 어려움을 가져올 수 있습니다.  토큰 만료 처리: JWT는 만료 시간을 설정할 수 있지만, 일단 발급된 토큰은 그 만료 시간까지 유효하며, 조기에 만료시키기 어렵습니다.  토큰 크기: JWT는 필요한 모든 정보를 포함하므로, 토큰의 크기가 커질 수 있습니다. 이는 네트워크 대역폭에 영향을 미치고, 특히 모바일 환경에서는 성능 저하의 원인이 될 수 있습니다.  성능 저하: 서버가 토큰을 검증할 때마다 서명을 계산해야 하므로, 고부하 환경에서는 성능 저하의 원인이 될 수 있습니다.취약점 정리      Signature 미검증Signature을 제대로 검증하지 않으면, Payload 부분만 변조하여 관리자 상승 및 타 사용자 계정 탈취 등의 취약점으로 이어질 수 있습니다.        정보 누출페이로드가 단순히 Base64 인코딩만 되어 있고 암호화되지 않은 경우 발생합니다. 이로 인해 민감한 데이터가 포함된 페이로드가 누구나 디코딩하여 읽을 수 있게 되어 정보 누출의 위험이 있습니다.    알고리즘 변경                  None 알고리즘alg 필드가 none으로 설정된 경우, 서명을 전혀 검증하지 않고 토큰을 유효한 것으로 간주하는 취약점이 있습니다. 이를 이용하면, 공격자는 서명 없이 토큰의 페이로드를 변조할 수 있고, 시스템은 이를 유효한 토큰으로 잘못 인식할 수 있습니다.                    비대칭 암호화 알고리즘을 대칭 암호화 알고리즘으로 변경하는 취약점비대칭 암호화 알고리즘을 대칭 암호화 알고리즘으로 변경하고 공개키를 대칭키(비밀키 또는 사전에 공유된 키)로 사용함으로써, 페이로드를 변조한 후에도 서명 검증을 통과할 수 있는 취약점이 있습니다. 이를 이용하면, 공격자는 페이로드 변조 후 비밀키로 서명하여 유효한 토큰으로 인식 시킬 수 있습니다.                  JWK InjectionJWT 헤더에 JWK를 포함시키고, 이를 통해 공개키 정보를 직접 제공하는 방식에서 발생합니다. 공격자는 변조된 토큰의 헤더에 자신이 생성한 JWK를 삽입하고, 이에 해당하는 비밀키로 서명을 생성할 수 있습니다. 서버가 이 JWK를 검증 없이 사용하여 토큰의 서명을 검증할 경우, 변조된 토큰이 유효한 것으로 잘못 인식될 위험이 있습니다.        JKU Spoofing서버가 JWT의 서명을 검증할 때, 헤더에 포함된 JKU URL에서 가져온 JSON Web Key (JWK)를 검증 없이 사용하는 경우 발생합니다. 공격자는 JKU 클레임을 조작하여 자신의 JWK URL을 삽입하고, 해당 URL에 포함된 자신의 키로 서명한 변조된 토큰을 생성할 수 있습니다. 서버가 이 변조된 JKU URL의 신뢰성을 검증하지 않고 사용할 경우, 변조된 토큰이 서버에 의해 유효한 것으로 잘못 인식되어 보안 위험에 노출됩니다.    kid 필드 취약점토큰의 헤더에 있는 kid 값을 이용하여 서버가 토큰 검증에 사용할 키를 찾는 과정에서 발생합니다. 서버는 DB나 파일 시스템에서 kid 값에 해당하는 키를 찾아 토큰을 검증합니다. 하지만, kid 값이 검증되지 않은 상태로 사용될 경우, 공격자는 이 값을 변조하여 SQL 인젝션, 경로 순회(Path Traversal), OS 명령어 인젝션 등의 공격을 시도할 수 있습니다. 이러한 공격은 서버의 보안을 위협하고, 토큰 검증을 우회하거나 시스템에 다른 피해를 입힐 수 있습니다. 따라서 서버는 kid 값을 사용하기 전에 신뢰성 있는 출처로부터 온 것인지 충분히 검증하고 필터링하는 과정이 필요합니다.",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2024/01/26/JWT-%E1%84%8E%E1%85%B1%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%8C%E1%85%A5%E1%86%B7-%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5/'> <img src='/images/Post-01.jpg' alt='JWT 취약점 정리'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>4 min read <time class='article__date' datetime='2024-01-26T21:51:00+09:00'>Jan 26, 2024</time> </span> </div><h2 class='article__title'>JWT 취약점 정리</h2> <p class='article__excerpt'>JWT (JSON Web Token)의 주요 취약점들에 대해 간략하게 정리하였습니다. 서명 미검증, 정보 누출, 알고리즘 변경, JWK 및 JKU 관련 취약점, 그리고 `kid` 필드 취약점 등 JWT의 보안 측면에 중점을 두고 설명하고 있습니다.</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='LRTK'><img class='article__author-image' src='/images/author.jpeg' alt='LRTK's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>LRTK</a><span> in </span> <span class='article-tags'> <a href='/tag/Korean' class='article__tag'>Korean</a>  <a href='/tag/Web' class='article__tag'>Web</a>  <a href='/tag/JWT' class='article__tag'>JWT</a> </span></div></div></div></div></div>"
    } ,
  
    {
      "title"    : "블로그 개편 작업",
      "category" : "",
      "tags"     : "",
      "url"      : "/2024/01/23/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B0%9C%ED%8E%B8-%EC%9E%91%EC%97%85/",
      "date"     : "Jan 23, 2024",
      "content": "깃허브 블로그 개편 작업 중",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2024/01/23/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B0%9C%ED%8E%B8-%EC%9E%91%EC%97%85/'> <img src='/images/Post-00.jpg' alt='블로그 개편 작업'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2024-01-23T15:26:00+09:00'>Jan 23, 2024</time> </span> </div><h2 class='article__title'>블로그 개편 작업</h2> <p class='article__excerpt'>깃허브 블로그 개편 작업 중</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='LRTK'><img class='article__author-image' src='/images/author.jpeg' alt='LRTK's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>LRTK</a></div></div></div></div></div>"
    } 
  
]
